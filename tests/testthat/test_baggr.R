context("Basic baggr() calls")
library(baggr)

# assuming test are for now always executed on WW's machine or similar
# we could enable this:
# options(mc.cores = 4)

warn_temp <- getOption("warn")
# options(warn = -1)

# prepare inputs ----------------------------------------------------------
set.seed(1990)

# pooled, with equal SE's!
df_pooled <- data.frame("tau" = c(1, -1, .5, -.5, .7, -.7, 1.3, -1.3),
                        "se" = rep(1, 8),
                        "state" = datasets::state.name[1:8])
# pooled, wide
df_pooled_mu <- data.frame("tau" = c(.1,.1, 3, 3.4, .7, .9), "se.tau" = c(1,1,2,2, .4, .6),
                           "mu" = c(0,0, 1, 1, .3, .3), "se.mu" = rep(.5, 6),
                           "group" = c("Site 1", "Site X", "A", "B", "Test 41", "Test 42"))
# individual
df_ind <- data.frame()
for(k in 1:5) {
  mu0 <- rnorm(1, 2, 2)
  p1 <- rnorm(100, mu0, 2)
  mu1 <- rnorm(1, mu0 + 0.5*mu0, 1)
  p2 <- rnorm(100, mu1, 2)
  df_ind <- rbind(df_ind,
                  data.frame(treatment = 1, outcome = p2, group = paste0("Site ", k)),
                  data.frame(treatment = 0, outcome = p1, group = paste0("Site ", k)))
}
# individual, custom column names
# df_ind_custom <- data.frame(profit = rnorm(100),
                            # village = rep(c("A", "B", "C", "D"), each = 25),
                            # ITT = rbinom(100, 1, .5))

# we also use microcredit df's that are built in



# tests ----------------------------------------------------------
test_that("Error messages for wrong inputs are in place", {
  # model doesn't exist
  expect_error(baggr(df_pooled, "made_up_model"), "Unrecognised model")
  # wrong model for this data
  expect_error(baggr(df_pooled, "mutau"), "Data provided is of type")
  # wrong column chosen
  expect_error(baggr(microcredit, group = "study"), "no column")
  # wrong column stops from finding what kind of data we're working with...
  expect_error(baggr(microcredit, outcome = "blabla"), "no column")
  # Default column doesn't exist
  expect_error(baggr(microcredit, model = "quantiles"), "There's no column outcome")
  # NA values are not allowed by default
  expect_error(baggr(microcredit, model = "quantiles",
                     quantiles = c(.1, .3, .5, .9), outcome = "profit"),
               "NA")
  # Stan warnings will be generated by default:
  expect_warning(baggr(df_pooled, "rubin"), "divergent transitions")

})



# basics & Rubin model tests -----

bg5_n <- baggr(df_pooled, "rubin", pooling = "none", group = "state",
               iter = 200, chains = 2)
bg5_p <- baggr(df_pooled, "rubin", pooling = "partial", group = "state",
               iter = 200, chains = 2)
bg5_f <- baggr(df_pooled, "rubin", pooling = "full", group = "state",
               iter = 200, chains = 2)

bg_ind1 <- baggr(df_ind, pooling = "none", iter = 200, chains = 2)
bg_ind2 <- baggr(df_ind, iter = 1000, chains = 2)
bg_ind3 <- baggr(df_ind, pooling = "full", iter = 200, chains = 2)
bg_mutau2 <- baggr(prepare_ma(df_ind), iter = 1000, chains = 2)

test_that("Extra args to Stan passed via ... work well", {
  expect_equal(nrow(as.matrix(bg5_p$fit)), 200)
})

test_that("Different pooling methods work for Rubin model", {
  expect_is(bg5_n, "baggr")
  expect_is(bg5_p, "baggr")
  expect_is(bg5_f, "baggr")
})

test_that("Pooling metrics are what they should be", {
  # all pooling metric are the same as SE's are the same
  expect_equal(length(unique(bg5_p$pooling_metric[1,,1])), 1) #expect_length()
  expect_equal(length(unique(bg5_p$pooling_metric[2,,1])), 1)
  expect_equal(length(unique(bg5_p$pooling_metric[3,,1])), 1)
  # all pooling stats are 0 if no pooling
  expect_equal(unique(as.numeric(bg5_n$pooling_metric)), 0)
  # full pooling means 1's everywhere
  expect_equal(unique(as.numeric(bg5_f$pooling_metric)), 1)

})

test_that("Different pooling methods work (don't crash) for full data", {
  expect_is(bg_ind1, "baggr")
  expect_is(bg_ind2, "baggr")
  expect_is(bg_ind3, "baggr")
})

test_that("Basic Rubin model has sensible results", {
  # compare Rubin model vs full information model
  ise <- apply(study_effects(bg_ind2), 2, mean)
  ase <- apply(study_effects(bg_mutau2), 2, mean)
  expect_lt(max(ise - ase), .05)

})


#

# Work in progress -----

# bg_mu1 <- baggr(df_pooled_mu, "mutau", joint_prior = 1, iter = 200, chains = 2)
# bg_mu2 <- baggr(df_pooled_mu, "mutau", joint_prior = 0, iter = 200, chains = 2)


test_that("Plotting works", {
  # plots happen at all with vanilla settings
  expect_is(plot(bg_ind1), "gg")
  # expect_is(plot(bg_mu1), "gg")
  expect_is(plot(bg5_f), "gg")
  # but we can crash it easily if
  expect_error(plot(bg5_n, style = "rubbish"), "argument must be one of")
})

options(warn = warn_temp)
