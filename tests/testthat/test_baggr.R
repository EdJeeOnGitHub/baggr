context("Basic baggr() calls")

# prepare inputs ----------------------------------------------------------

# pooled, with equal SE's!
df_pooled <- data.frame("tau" = c(1, -1, .5, -.5, .7, -.7, 1.3, -1.3),
                        "se" = rep(1, 8),
                        "state" = datasets::state.name[1:8])
# pooled, wide
df_pooled_mu <- data.frame("tau" = c(.1,.1), "se.tau" = c(1,1),
                           "mu" = c(0,0), "se.mu" = c(1,1),
                           "site" = c("Site 1", "Site X"))
# individual
df_ind <- data.frame(outcome = rnorm(100),
                     site = rep(c("A", "B", "C", "D"), each = 25),
                     treatment = rbinom(100, 1, .5))
# individual, custom column names
df_ind_custom <- data.frame(profit = rnorm(100),
                            village = rep(c("A", "B", "C", "D"), each = 25),
                            ITT = rbinom(100, 1, .5))

# we also use microcredit df's that are built in



# tests ----------------------------------------------------------
test_that("Error messages for wrong inputs are in place", {
  # model doesn't exist
  expect_error(baggr(df_pooled, "made_up_model"), "Unrecognised model")
  # wrong model for this data
  expect_error(baggr(df_pooled, "mutau"), "Data provided is of type")
  # wrong column chosen
  expect_error(baggr(microcredit, grouping = "study"), "No outcome column")
  # wrong column stops from finding what kind of data we're working with...
  expect_error(baggr(microcredit, grouping = "blabla"), "Cannot automatically determine type of input data.")
  # Stan warnings will be generated by default:
  expect_warning(baggr(df_pooled, "rubin"), "divergent transitions")
})



# basics & Rubin model tests -----

bg5_n <- baggr(df_pooled, "rubin", pooling = "none", grouping = "state",
               iter = 200, chains = 2)
bg5_p <- baggr(df_pooled, "rubin", pooling = "partial", grouping = "state",
               iter = 200, chains = 2)
bg5_f <- baggr(df_pooled, "rubin", pooling = "full", grouping = "state",
               iter = 200, chains = 2)

test_that("Extra args to Stan passed via ... work well", {
  expect_equal(nrow(as.matrix(bg5_p$fit)), 200)
})

test_that("Different pooling methods work for Rubin model", {
  expect_is(bg5_n, "baggr")
  expect_is(bg5_p, "baggr")
  expect_is(bg5_f, "baggr")
})

test_that("Pooling metrics are what they should be", {
  # all pooling metric are the same as SE's are the same
  expect_equal(length(unique(bg5_p$pooling_metric[,1])), 1) #expect_length()
  expect_equal(length(unique(bg5_p$pooling_metric[,2])), 1)
  expect_equal(length(unique(bg5_p$pooling_metric[,3])), 1)

  # no pooling means 0's everywhere
  expect_equal(unique(as.numeric(bg5_n$pooling_metric)), 0)

})

# test_that("Basic Rubin model has sensible results", {
# ...
# })



# Work in progress -----

bg2 <- baggr(df_pooled_mu, "mutau")
bg3 <- baggr(df_ind_custom, "joint",
             grouping = "village", outcome = "profit", treatment = "ITT")

test_that("Plotting works", {
  # plots happen at all with vanilla settings
  expect_is(plot(bg5_n), "gg")
  expect_is(plot(bg2), "gg")
  expect_is(plot(bg3), "gg")
  # we can crash it
  expect_error(plot(bg5_n, style = "rubbish"), "argument must be one of")
})


#
# bg1 <- baggr(df_pooled, "rubin")

# class(bg)
#
# # naming of sites
# bg_sites <- baggr(data.frame(df_pooled, "site" = LETTERS[1:nrow(df_pooled)]), "rubin")
# plot(bg_sites)

# #different kinds of pooling:
# bg_none <- baggr(df_pooled, "rubin", pooling = "none")
# bg_partial <- baggr(df_pooled, "rubin", pooling = "partial")
# # bg_full <- baggr(df_pooled, "rubin", pooling = "full")
